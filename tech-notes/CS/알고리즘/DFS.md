# DFS (Depth-First Search)
## **1️⃣ 개념**
깊이 우선 탐색(DFS)은 그래프 또는 트리에서 가능한 깊이까지 탐색한 후 **백트래킹(되돌아가며 탐색)을 수행하는 알고리즘**이다.  
재귀 방식을 활용하여 구현할 수 있으며, 모든 노드를 방문하는 데 사용된다.

### **📌 DFS의 특징**
- 한 경로를 따라 **최대한 깊이 탐색한 후**, 더 이상 진행할 수 없을 때 **역순 처리(백트래킹)**.
- **재귀(Recursion) 또는 스택(Stack) 자료구조를 이용하여 구현 가능**.
- **시간 복잡도**: O(V + E) (V: 노드 개수, E: 간선 개수)
- **DFS 활용 사례**:
  - 그래프의 경로 탐색
  - 순열과 조합 생성
  - 백트래킹 문제 (예: 완전 탐색, 최적화 문제)

---
## **2️⃣ DFS 구현 방법**
DFS는 **재귀 호출 방식**과 **스택을 활용한 반복문 방식**으로 구현할 수 있다.

### **DFS 코드(재귀)**
```javascript
function dfs(node) {
    const nextNode = graph[node];
    while (nextNode && nextNode.length > 0) {
        dfs(nextNode.shift());
    }
    result.push(node);
}
```
### 📌 동작 방식
- dfs(node) 함수는 현재 노드에서 시작하여, 연결된 모든 노드를 탐색한다.
- 이 때, 재귀방식은 후입선출 방식이므로 연결된 노드가 더 이상 없을 때, 해당 노드는 결과 배열(result)에 역순으로 추가된다.
- 반면, 스택을 활용한 반복문을 구성해보려면 반복문 후에 reverse()를 통해 역순처리 필요하다.

---

## 3️⃣ DFS의 역순 처리 (왜 DFS는 역순으로 처리되는가?)
DFS가 역순으로 노드를 처리하는 이유는 재귀 호출의 특성 때문이다.

### 실행 순서 예시
탐색 순서: dfs("A") → dfs("B") → dfs("C") → dfs("D")
- 여기서 "D"는 더 이상 갈 곳이 없으므로 result.push("D")가 호출된다.
- "D" 처리 후, 함수 호출이 종료되고, 다시 "C"로 돌아간다. 이제 "C"에서 할 일이 모두 끝났으므로 result.push("C")가 호출된다. 이후 "B"로 돌아가서 result.push("B"), 마지막으로 "A"로 돌아가서 result.push("A")가 호출된다.
- result 배열에는 [D, C, B, A]가 기록된다.

📌 결과
result 배열: ["D", "C", "B", "A"]

```javascript
// 스택에 쌓이는 순서:
dfs("A")
    dfs("B")
        dfs("C")
            dfs("D")
                → "D" 완료 (스택에서 제거)
            → "C" 완료 (스택에서 제거)
        → "B" 완료 (스택에서 제거)
    → "A" 완료 (스택에서 제거)
```
